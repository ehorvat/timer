package interview.oreilly.controller;

import android.app.Activity;
import android.content.Context;
import android.content.ContextWrapper;
import android.os.Bundle;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewParent;

import com.qozix.spatula.Spatula;

//import oreilly.spatula.Spatula;

/**
 * Created by michaeldunn on 7/13/16.
 *
 * This class provides logic and behavior for Views.
 * Since this class is likely to retain references to View instances, ensure that references to it are not
 * retained outside of the containing Activity's lifecycle (e.g., Service, BroadcastReceiver).
 */
public abstract class ViewController implements Presenter {

  private View mView;
  private View.OnAttachStateChangeListener mOnAttachStateChangeListener = new View.OnAttachStateChangeListener() {
    @Override
    public void onViewAttachedToWindow(View v) {
      uiAttached();
    }

    @Override
    public void onViewDetachedFromWindow(View v) {
      uiDetached();
    }
  };

  /**
   * Gets the View instance returned by #createUi (and so is not available in that method).
   *
   * @return The View instance returned by #createUi.
   */
  public View getView() {
    return mView;
  }

  /**
   * Sets view.
   *
   * @param view the view
   */
  protected void setView(View view) {
    mView = view;
    mView.addOnAttachStateChangeListener(mOnAttachStateChangeListener);
  }

  /**
   * Convenience method to fetch and cast the Activity this ViewController is within.
   *
   * @param <T> the type parameter
   * @return activity
   */
  @SuppressWarnings("unchecked")
  public <T extends Activity> T getActivity() {
    Context context = getView().getContext();
    while (!(context instanceof Activity) && context instanceof ContextWrapper) {
      ContextWrapper contextWrapper = (ContextWrapper) context;
      context = contextWrapper.getBaseContext();
    }
    return (T) context;
  }

  /**
   * Subclasses should override this method to provide a View UI.
   *
   * Note that further processing is applied to the return of this method, so additional decoration should
   * generally happen in #uiCreated.  The #getView method will return null until this method has returned.
   *
   * @param context the context
   * @return The View instance that will be the UI of this ViewController.
   */
  public abstract View createUi(Context context);

  @Override
  public abstract void uiCreated(Bundle savedInstanceState);

  @Override
  public abstract void uiAttached();

  @Override
  public abstract void uiDetached();

  /**
   * ViewController instances should always be generated by a Factory instance.
   *
   * We did not make ViewController constructor private for a couple reasons:
   * 1.  Every subclass would have to stub out the constructor, and
   * 2.  We do want to allow subclasses to perform work in their constructor
   *
   * Note that the constructor will be called using the Factory, but it will always use the no-argument version.
   * DO NOT MAKE ViewController SUBCLASS CONSTRUCTORS WITH ARGUMENTS
   *
   * Since we retain an instance to a Context, we immediately look up for an ApplicationContext to avoid leaks -
   * however, ensure that a reference to a Factory instance never persists outside the Application (e.g., a Service).
   */
  public static class Factory {


    private Context mContext;

    /**
     * Create a Factory instance to generate concrete ViewController subclass instances.
     *
     * @param context A Context instance.  This is retained; Factory instances should not persist.
     */
    public Factory(Context context) {
      mContext = context;
    }

    /**
     * Use this method to create an instance of the passed-in ViewController subclass.
     *
     * @param <T>   The ViewController subclass reference.
     * @param clazz The ViewController subclass type to instantiate.
     * @param savedInstanceState the saved instance state
     * @return The instance of the ViewController subclass.
     * @throws InstantiationException the instantiation exception
     * @throws IllegalAccessException the illegal access exception
     */
    public <T extends ViewController> T create(Class<T> clazz, Bundle savedInstanceState) throws InstantiationException, IllegalAccessException {
      return create(clazz, null, null);
    }

    /**
     * Create t.
     *
     * @param <T>       the type parameter
     * @param clazz     the clazz
     * @param decorator the decorator
     * @param savedInstanceState the saved instance state
     * @return the t
     * @throws InstantiationException the instantiation exception
     * @throws IllegalAccessException the illegal access exception
     */
    public <T extends ViewController> T create(Class<T> clazz, Decorator decorator, Bundle savedInstanceState) throws InstantiationException, IllegalAccessException {
      T viewController = clazz.newInstance();
      if (decorator != null) {
        decorator.decorate(mContext, viewController);
      }
      View rootView = viewController.createUi(mContext);
      viewController.setView(rootView);
      Spatula.bind(viewController, rootView);
      viewController.uiCreated(savedInstanceState);
      return viewController;
    }

    /**
     * The interface Decorator.
     */
    public interface Decorator {
      /**
       * Decorate.
       *
       * @param context        the context
       * @param viewController the view controller
       */
      void decorate(Context context, ViewController viewController);
    }

  }

}
